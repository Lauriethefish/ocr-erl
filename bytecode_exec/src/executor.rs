//! Executes the generated bytecode.
use erl_parser::ast::BinaryOperator;

use crate::{
    bytecode::{Instruction, Module, SubProgram},
    err::RuntimeError,
    rcstr::RcStr,
    stack::{Stack, StackFrame},
    Type, Value,
};

/// Stores the currently executing instruction of a sub-program
struct InstructionState<'a> {
    /// The sub-program being executed
    sub_program: &'a SubProgram,
    /// The currently executing instruction
    instruction_ptr: usize,
}

impl<'a> InstructionState<'a> {
    /// Creates an [InstructionState], beginning execution at the start of the given [SubProgram].
    fn at_beginning_of(sub_program: &'a SubProgram) -> Self {
        Self {
            sub_program,
            instruction_ptr: 0,
        }
    }
}

/// Stores the state of execution of a sub-program whose execution has been paused,
/// due to a (non-native) sub-program call.
struct ExecState<'a> {
    /// The instruction to continue with when execution is resumed
    instruction: InstructionState<'a>,
    /// The stack frame in which execution was paused.
    frame: StackFrame,
}

/// Executes the main sub-program within the given module
pub fn execute_main(module: &Module) -> Result<(), RuntimeError> {
    execute_idx(module, module.main_idx(), &[])?;

    Ok(())
}

/// Executes the sub program with the given name within the given module.
pub fn execute_by_name(
    module: &Module,
    name: &str,
    args: &[Value],
) -> Result<Option<Value>, RuntimeError> {
    for (idx, sub_program) in module.sub_programs().iter().enumerate() {
        if sub_program.name.as_deref() != Some(name) {
            continue;
        }

        return execute_idx(module, idx, args);
    }

    Err(RuntimeError::NoSuchSubProgram(name.to_owned()))
}

#[inline]
fn begin_stack_frame(
    stack: &mut Stack,
    sub_program: &SubProgram,
) -> Result<StackFrame, RuntimeError> {
    stack.begin_new_stack_frame(
        sub_program.arg_count,
        sub_program.local_count,
        sub_program.max_stack_space,
    )
}

/// Executes the sub program with the given index within the given module.
#[inline(never)]
fn execute_idx(
    module: &Module,
    sub_program_idx: usize,
    args: &[Value],
) -> Result<Option<Value>, RuntimeError> {
    // Create the stack which holds values being used by functions
    let mut stack = Stack::new(8192);
    let mut call_stack = Vec::new();

    // Begin a new stack frame for the main procedure.
    // This is important since it makes the local variables of the main procedure
    // (which are known as global variables) available to other sub-programs.
    let main_proc = module.main();
    begin_stack_frame(&mut stack, main_proc)?;

    // Prepare the stack for the sub-program we're starting execution at, if it isn't main
    let entry_sub_program = module.sub_program(sub_program_idx);
    if entry_sub_program != main_proc {
        if args.len() != entry_sub_program.arg_count {
            return Err(RuntimeError::WrongNumberOfArguments {
                name: entry_sub_program
                    .name
                    .clone()
                    .expect("Non-main sub-program will always have a name"),
                expected: entry_sub_program.arg_count,
                actual: args.len(),
            });
        }

        // Push the arguments of the entry sub-program to the stack.
        for arg in args {
            stack.push(arg.clone())?;
        }
        // Simulate a call to the entry sub-program
        begin_stack_frame(&mut stack, entry_sub_program)?;
    }

    // Start execution at the beginning of the entry sub-program
    let mut state = InstructionState::at_beginning_of(entry_sub_program);
    loop {
        let instruction = match state
            .sub_program
            .instructions
            .get(state.instruction_ptr as usize)
        {
            Some(instruction) => instruction,
            None => &Instruction::Return, // If we are out of instructions, we will execute `Return` to move back up the call stack.
        };

        match instruction {
            // Very repetitive code for binary operations.
            // This code could be moved elsewhere, but I decided against it, since the functions wouldn't be used much elsewhere.
            Instruction::Add => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left + right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left + right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 + right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left + right))
                },
                (Value::String(right), Value::String(left)) => unsafe {
                    stack.push_unchecked(Value::String(RcStr::concat(&*left, &*right)))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Add)),
            },
            Instruction::Subtract => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left - right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left - right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 - right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left - right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Subtract)),
            },
            Instruction::Multiply => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left * right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left * right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 * right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left * right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Multiply)),
            },
            Instruction::Divide => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 / right as f64))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left / right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 / right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left / right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Divide)),
            },
            Instruction::Remainder => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left % right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Remainder)),
            },
            Instruction::Quotient => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left / right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Quotient)),
            },
            Instruction::Power => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left.pow(right as u32)))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left.powf(right as f64)))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real((left as f64).powf(right)))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left.powf(right)))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Power)),
            },
            Instruction::GreaterThan => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left > right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::GreaterThan,
                    ))
                }
            },
            Instruction::GreaterThanOrEquals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left >= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::GreaterThanOrEquals,
                    ))
                }
            },
            Instruction::LessThan => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left < right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left < right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if (left as f64) < right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left < right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::LessThan)),
            },
            Instruction::LessThanOrEquals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left <= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left <= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if (left as f64) <= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left <= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::LessThanOrEquals,
                    ))
                }
            },
            Instruction::Equals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left == right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::True, Value::True) => unsafe { stack.push_unchecked(Value::True) },
                (Value::True, Value::False) => unsafe { stack.push_unchecked(Value::False) },
                (Value::False, Value::True) => unsafe { stack.push_unchecked(Value::False) },
                (Value::False, Value::False) => unsafe { stack.push_unchecked(Value::True) },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Equals)),
            },
            Instruction::NotEquals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left != right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::True, Value::True) => unsafe { stack.push_unchecked(Value::False) },
                (Value::True, Value::False) => unsafe { stack.push_unchecked(Value::True) },
                (Value::False, Value::True) => unsafe { stack.push_unchecked(Value::True) },
                (Value::False, Value::False) => unsafe { stack.push_unchecked(Value::False) },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::NotEquals)),
            },
            Instruction::Not => match unsafe { stack.pop_unchecked() } {
                Value::True => unsafe { stack.push_unchecked(Value::False) },
                Value::False => unsafe { stack.push_unchecked(Value::True) },
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfTrue(idx) => match unsafe { stack.pop_unchecked() } {
                Value::True => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                Value::False => {}
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfFalse(idx) => match unsafe { stack.pop_unchecked() } {
                Value::True => {}
                Value::False => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfFalsePopIfTrue(idx) => match unsafe { stack.peek_unchecked() } {
                Value::True => unsafe {
                    stack.pop_unchecked();
                },
                Value::False => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfTruePopIfFalse(idx) => match unsafe { stack.peek_unchecked() } {
                Value::True => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                Value::False => unsafe {
                    stack.pop_unchecked();
                },
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::Jump(idx) => {
                state.instruction_ptr = *idx;
                continue;
            }
            Instruction::Call(func_idx) => {
                let to_call = module.sub_program(*func_idx);
                let pre_call_frame = begin_stack_frame(&mut stack, to_call)?;

                call_stack.push(ExecState {
                    instruction: state,
                    frame: pre_call_frame,
                });
                state = InstructionState::at_beginning_of(to_call);
                continue;
            }
            Instruction::Return => {
                if state.sub_program.is_function {
                    return Err(RuntimeError::MustReturnValueFromFunction);
                }

                let caller_state = match call_stack.pop() {
                    Some(state) => state,
                    None => return Ok(None),
                };

                stack.return_to_frame(caller_state.frame);
                state = caller_state.instruction;
            }
            Instruction::ReturnValue => {
                if !state.sub_program.is_function {
                    return Err(RuntimeError::CannotReturnValueFromProcedure);
                }

                let caller_state = match call_stack.pop() {
                    Some(state) => state,
                    None => return Ok(Some(unsafe { stack.pop_unchecked() })),
                };

                stack.return_value_to_frame(caller_state.frame);
                state = caller_state.instruction;
            }
            Instruction::LoadInteger(int) => unsafe { stack.push_unchecked(Value::Integer(*int)) },
            Instruction::LoadReal(real) => unsafe { stack.push_unchecked(Value::Real(*real)) },
            Instruction::LoadTrue => unsafe { stack.push_unchecked(Value::True) },
            Instruction::LoadFalse => unsafe { stack.push_unchecked(Value::False) },
            Instruction::LoadString(string) => unsafe {
                stack.push_unchecked(Value::String(string.clone()))
            },
            Instruction::Load(local_idx) => unsafe { stack.push_local_unchecked(*local_idx) },
            Instruction::LoadGlobal(global_idx) => unsafe {
                stack.push_global_unchecked(*global_idx)
            },
            Instruction::Save(local_idx) => unsafe { stack.save_to_local_unchecked(*local_idx) },
            Instruction::PeekSave(local_idx) => unsafe {
                stack.peek_save_to_local_unchecked(*local_idx)
            },

            Instruction::SaveGlobal(global_idx) => unsafe {
                stack.save_to_global_unchecked(*global_idx)
            },
            Instruction::Pop => {
                unsafe { stack.pop_unchecked() };
            }
            Instruction::Throw(err) => return Err((**err).clone()),
            Instruction::Nop => {}
            Instruction::CallNative(call_info) => unsafe { call_info.call(&mut stack)? },
        };

        // Advance to the next instruction
        state.instruction_ptr += 1;
    }
}
