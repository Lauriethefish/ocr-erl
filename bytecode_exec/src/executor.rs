//! Executes the generated bytecode.

use erl_parser::ast::BinaryOperator;

use crate::{
    bytecode::{Instruction, SubProgram},
    err::RuntimeError,
    rcstr::RcStr,
    stdlib::{Type, Value},
};

use std::fmt::Debug;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn stack_new_should_fill_with_zeroed_ints() {
        for value in Stack::new(64).contents.iter() {
            assert_eq!(&Value::Integer(0), value);
        }
    }

    #[test]
    fn stack_new_should_create_with_correct_size() {
        assert_eq!(64, Stack::new(64).contents.len());
    }

    #[test]
    fn stack_push_should_assign_and_increment_ptr() {
        let mut stack = Stack::new(64);
        stack.push(Value::Integer(5));
        assert_eq!(Value::Integer(5), stack.contents[0]);
        assert_eq!(1, stack.top);
    }

    #[test]
    fn stack_pop_should_clone_and_decrement_ptr() {
        let mut stack = Stack::new(64);
        stack.contents[0] = Value::Integer(6);
        stack.top = 1;
        assert_eq!(Value::Integer(6), stack.pop());
        assert_eq!(0, stack.top);
    }

    #[test]
    fn stack_push_local_should_push_from_bottom_of_locals() {
        let mut stack = Stack::new(64);
        stack.contents[0] = Value::Integer(5); // This will act as our first local
        stack.top = 1;

        stack.push_local(0); // Push our first local to stack
        assert_eq!(Value::Integer(5), stack.contents[1]); // Should be pushed above the local
        assert_eq!(2, stack.top);
    }

    #[test]
    fn stack_push_global_should_push_from_bottom_of_stack() {
        let mut stack = Stack::new(64);
        stack.contents[0] = Value::Integer(5); // This will act as our first global

        stack.bottom_func = 1; // Set the bottom of our current function to above the global
        stack.top = 1;
        stack.push_global(0);

        // The global, which is not within our function, should be read instead of the first local
        assert_eq!(Value::Integer(5), stack.contents[1]);
        assert_eq!(2, stack.top);
    }

    #[test]
    fn stack_save_local_should_assign_to_bottom_of_locals() {
        let mut stack = Stack::new(64);
        // Assign an example value
        stack.contents[0] = Value::Integer(5);
        stack.contents[1] = Value::Integer(6); // Value that we are saving to the local
        stack.top = 2;

        stack.save_local(0);
        assert_eq!(Value::Integer(6), stack.contents[0]); // Local should be replaced with our variable
        assert_eq!(1, stack.top);
    }

    #[test]
    fn stack_save_global_should_assign_to_bottom_of_stack() {
        let mut stack = Stack::new(64);
        // Assign an example value
        stack.contents[0] = Value::Integer(5);
        stack.contents[1] = Value::Integer(6); // Value that we are saving to the local
        stack.top = 2;
        stack.bottom_func = 1; // Set the bottom of our current function to above the global

        stack.save_global(0);
        // Despite the global being below the bottom of the stack frame, it should still be assigned to
        assert_eq!(Value::Integer(6), stack.contents[0]);
        assert_eq!(1, stack.top);
    }

    #[test]
    fn stack_move_to_caller_should_restore_stack_frame() {
        let exec_state = StackState {
            stack_frame_top: 10,
            stack_frame_bottom: 5,
        };
        let mut stack = Stack::new(64);
        stack.move_to_caller(exec_state);

        assert_eq!(10, stack.top);
        assert_eq!(5, stack.bottom_func);
    }

    #[test]
    fn stack_return_to_caller_should_push_result() {
        let mut stack = Stack::new(64);

        // Place a value at the top of the stack for returning
        stack.contents[9] = Value::Integer(10);
        stack.top = 10;

        // We are assuming that we called the function from the bottom of the stack
        let exec_state = StackState {
            stack_frame_top: 0,
            stack_frame_bottom: 0,
        };

        stack.return_to_caller(exec_state);

        // The return value should be pushed to the top of the stack
        assert_eq!(Value::Integer(10), stack.contents[0]);
        assert_eq!(1, stack.top);
    }
}

#[derive(Clone, PartialEq)]
struct CheckedSubProgram {
    /// The sub-program
    inner: SubProgram,
    /// The maximum stack offset that this sub-program will push to from the bottom of its locals.
    max_stack_size: usize,
}

impl Debug for CheckedSubProgram {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!(
            "{:#?} (max stack size: {})",
            self.inner, self.max_stack_size
        ))
    }
}

/// Contains all of the compiled sub-programs within an ERL file.
///
/// This is not placed within the `bytecode` module, since in order to ensure safety for the executor,
/// it has to uphold certain guarantees about the instructions within sub-programs.
#[derive(Clone)]
pub struct Module {
    /// The sub-programs within the ERL file.
    sub_programs: Vec<CheckedSubProgram>,

    /// The index of the main sub-program within the module.
    main_idx: usize,
}

impl Module {
    /// Creates a new [Module].
    ///
    /// # Arguments
    /// * `sub_programs` - the sub-programs within the module.
    /// * `main_idx` - the index of the main procedure within `sub_programs`.
    ///
    /// # Panics
    /// This function will panic if:
    /// * `main_idx` is not the index of a sub-program within the module.
    /// * `main_idx` points to a procedure.
    /// * `main_idx` points to a sub-program that has more than 0 arguments.
    /// * Any of the sub-programs contain instructions that could manipulate the stack in a way that
    /// causes an overflow or underflow.
    /// * Any of the sub-programs contain a code path which can reach a given instruction with multiple stack
    /// sizes.
    pub(crate) fn new(sub_programs: Vec<SubProgram>, main_idx: usize) -> Module {
        let main = sub_programs
            .get(main_idx)
            .expect("The given `main_idx` was outside `sub_programs`");
        if main.is_function {
            panic!("The sub-program pointed to by `main_idx` was a procedure!")
        }
        if main.arg_count > 0 {
            panic!("The sub-program pointed to by `main_idx` had more than 0 arguments!")
        }

        let mut result = Vec::new();
        for sub_program in sub_programs.iter() {
            let max_stack_size = Self::find_maximum_stack_space(&sub_programs, sub_program);

            result.push(CheckedSubProgram {
                inner: sub_program.clone(),
                max_stack_size,
            });
        }

        Module {
            sub_programs: result,
            main_idx,
        }
    }

    /// Finds the maximum space on the stack that could be required by the given sub-program.
    ///
    /// Note that this function is **vital** to ensure later safety of execution.
    /// To improve performance, the executor uses `unchecked` reads and writes to the stack (this provided a 40% speedup in benchmarks).
    /// Thus, we need to make sure that the generated bytecode could never lead to a read which is outside the current stack.
    ///
    /// This function ensures this by walking through the instructions in a sub-program, and calculating the stack size that executing
    /// each instruction would result in. To verify that these sizes will be correct no matter the execution path, this function
    /// also makes sure that the stack size at the jump-site of any control-flow instruction (e.g. [`Instruction::Jump`]) matches
    /// the stack size after that instruction is run.
    fn find_maximum_stack_space(sub_programs: &[SubProgram], sub_program: &SubProgram) -> usize {
        // Keeps track of the stack size before each instruction.
        // This allows us to make sure that each instruction is only reachable with one stack-size.
        // If `None` is the value for a given instruction index, this means that the instruction is yet to be iterated.
        let mut stack_sizes_before_idx = vec![None; sub_program.instructions.len()];

        // To begin with, the offset from the bottom of the stack frame will be equal to the number of locals
        let mut size: isize = sub_program.local_count as isize;

        let mut max_size: isize = size;

        let mut idx = 0;
        while idx < sub_program.instructions.len() {
            // Add the stack size before this instruction, or, if this instruction has already been jumped to
            // elsewhere, verify that the stack size after the jump matches the stack size at this point.
            Self::add_or_verify_size_matches(&mut stack_sizes_before_idx, idx, size);

            match &sub_program.instructions[idx] {
                Instruction::Add
                | Instruction::Subtract
                | Instruction::Multiply
                | Instruction::Divide
                | Instruction::Remainder
                | Instruction::Quotient
                | Instruction::Power
                | Instruction::GreaterThan
                | Instruction::GreaterThanOrEquals
                | Instruction::LessThan
                | Instruction::LessThanOrEquals
                | Instruction::Equals
                | Instruction::NotEquals => {
                    // All binary operators pop 2 operands and then push the result
                    // Note that we can NOT just use an overall diff of -1, since we need to verify that there are
                    // two values on the stack available to be popped.
                    Self::diff(&mut size, -2);
                    Self::diff(&mut size, 1);
                }
                Instruction::Not => {
                    // While the overall diff here is 0, we must verify that we
                    // can pop one value of the stack to perform the operation on.
                    Self::diff(&mut size, -1);
                    Self::diff(&mut size, 1);
                }
                Instruction::JumpIfTrue(to) | Instruction::JumpIfFalse(to) => {
                    Self::diff(&mut size, -1); // Popping off the `true`/`false` argument
                                               // Make sure that the size of the stack before executing the instruction we're jumping to matches the stack size after this jump.
                    Self::add_or_verify_size_matches(&mut stack_sizes_before_idx, *to, size);
                }
                Instruction::JumpIfFalsePopIfTrue(to) | Instruction::JumpIfTruePopIfFalse(to) => {
                    // Make sure that the size of the stack before executing the instruction we're jumping to matches the stack size after this jump.
                    Self::add_or_verify_size_matches(&mut stack_sizes_before_idx, *to, size);
                    Self::diff(&mut size, -1); // If execution continues in the current path, the stack size will decrease by 1
                }
                Instruction::Jump(to) => {
                    // Make sure that the size of the stack before executing the instruction we're jumping to matches the stack size after this jump.
                    Self::add_or_verify_size_matches(&mut stack_sizes_before_idx, *to, size);
                }
                Instruction::Call(idx) => {
                    let to_call = sub_programs
                        .get(*idx)
                        .expect("Invalid sub-program idx in call");

                    // To call, we need at least the correct number of arguments on stack
                    Self::diff(&mut size, -(to_call.arg_count as isize));

                    // After a function call, an extra value is pushed to stack
                    if to_call.is_function {
                        Self::diff(&mut size, 1);
                    }
                }
                Instruction::CallNative(to_call) => {
                    // To call, we need at least the correct number of arguments on stack
                    Self::diff(&mut size, -(to_call.arg_count as isize));

                    // After a function call, an extra value is pushed to stack
                    if to_call.is_function {
                        Self::diff(&mut size, 1);
                    }
                }
                Instruction::Return => {}
                // Returning a value requires a value on the top of the stack to be popped.
                Instruction::ReturnValue => Self::diff(&mut size, -1),

                // Loading always pushes one value to stack.
                Instruction::LoadInteger(_)
                | Instruction::LoadReal(_)
                | Instruction::LoadTrue
                | Instruction::LoadFalse
                | Instruction::LoadString(_)
                | Instruction::Load(_)
                | Instruction::LoadGlobal(_) => Self::diff(&mut size, 1),

                // Saving always pops one value from stack.
                Instruction::Save(_) | Instruction::SaveGlobal(_) => Self::diff(&mut size, -1),
                Instruction::Pop => Self::diff(&mut size, -1),
                Instruction::Throw(_) => {
                    // If an error instruction is found, the code path from this point onwards should be ignored.
                    // Thus, we will continue checking stack sizes at the next instruction that already has a stack size
                    // assigned, since this instruction must be reachable by a jump in the instructions already iterated.

                    idx += 1; // Run this first to skip the current instruction
                    while idx < sub_program.instructions.len() {
                        // Once we reach an instruction that could be jumped too, continue checking stack sizes at that point
                        if let Some(other_size) = stack_sizes_before_idx[idx] {
                            size = other_size; // Ignore the stack size after throwing
                            break;
                        }

                        idx += 1;
                    }

                    continue;
                }
                Instruction::Nop => {}
            };

            if size > max_size {
                max_size = size;
            }

            idx += 1;
        }

        max_size as usize
    }

    fn add_or_verify_size_matches(sizes: &mut [Option<isize>], idx: usize, size: isize) {
        match sizes[idx] {
            Some(existing) => {
                if existing != size {
                    panic!("Instruction idx {idx} can be reached with multiple stack sizes!")
                }
            }
            None => sizes[idx] = Some(size),
        }
    }

    fn diff(size: &mut isize, diff: isize) {
        let new_size = size
            .checked_add(diff)
            .expect("Executing this code will result in a stack overflow!");
        if new_size < 0 {
            panic!("Executing this code will result in a stack underflow!");
        }

        *size = new_size;
    }
}

impl Debug for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Module")
            .field("sub_programs", &self.sub_programs)
            .finish()
    }
}

/// Stores the current state of the stack during paused execution of a function
struct StackState {
    /// The top of the stack frame
    stack_frame_top: usize,
    /// The bottom of the stack frame (where local variables start)
    stack_frame_bottom: usize,
}

/// Stores the currently executing instruction of a sub-program
struct InstructionState<'a> {
    /// The sub-program being executed
    sub_program: &'a SubProgram,
    /// The currently executing instruction
    instruction_ptr: usize,
}

impl<'a> InstructionState<'a> {
    /// Creates an [InstructionState], beginning execution at the start of the given [SubProgram].
    fn at_beginning_of(sub_program: &'a SubProgram) -> Self {
        Self {
            sub_program,
            instruction_ptr: 0,
        }
    }
}

/// Stores the state of execution of a sub-program whose execution has been paused,
/// due to a (non-native) sub-program call.
struct ExecState<'a> {
    /// The instruction to continue with when execution is resumed
    instruction: InstructionState<'a>,
    /// The stack state when execution was paused.
    stack: StackState,
}

/// A virtual stack for the interpreter.
pub(crate) struct Stack {
    /// The values within the stack.
    contents: Box<[Value]>,
    /// The stack index of the first local variable within the current sub-program
    bottom_func: usize,
    /// The stack index of the first value that is NOT part of the stack
    top: usize,
}

impl Stack {
    /// Creates a new stack with the given size.
    /// All values within the stack will be `Value::Integer(0)`.
    fn new(size: usize) -> Self {
        let mut elements = Vec::new();
        elements.reserve_exact(size);
        for _ in 0..size {
            elements.push(Value::Integer(0));
        }

        Self {
            contents: elements.into(),
            bottom_func: 0,
            top: 0,
        }
    }

    /// Removes the value at the top of the stack, and returns it.
    #[inline(always)]
    pub(crate) fn pop(&mut self) -> Value {
        self.top -= 1;
        self.contents[self.top].clone()
    }

    /// Removes the value at the top of the stack, and returns it.
    /// Does no bounds checking.
    #[inline(always)]
    unsafe fn pop_unchecked(&mut self) -> Value {
        self.top -= 1;
        self.contents.get_unchecked(self.top).clone()
    }

    /// Removes the top two values from the stack and returns them.
    /// Does no bounds checking.
    #[inline(always)]
    unsafe fn pop_twice_unchecked(&mut self) -> (Value, Value) {
        self.top -= 2;
        (
            self.contents.get_unchecked(self.top + 1).clone(),
            self.contents.get_unchecked(self.top).clone(),
        )
    }

    /// Returns a clone of the top value of the stack, without removing it.
    #[inline(always)]
    pub fn peek(&self) -> Value {
        self.contents[self.top - 1].clone()
    }

    /// Returns a clone of the top value of the stack, without removing it.
    /// Does no bounds checking.
    #[inline(always)]
    unsafe fn peek_unchecked(&mut self) -> Value {
        self.contents.get_unchecked(self.top - 1).clone()
    }

    /// Pushes a value to the top of the stack.
    #[inline(always)]
    pub(crate) fn push(&mut self, value: Value) {
        self.contents[self.top] = value;
        self.top += 1;
    }

    /// Pushes a value to the top of the stack.
    /// Does no bounds checking.
    #[inline(always)]
    unsafe fn push_unchecked(&mut self, value: Value) {
        *self.contents.get_unchecked_mut(self.top) = value;
        self.top += 1;
    }

    /// Pushes the local with the given index to the top of the stack
    #[inline(always)]
    fn push_local(&mut self, idx: usize) {
        self.push(self.contents[self.bottom_func + idx as usize].clone());
    }

    /// Pushes the local with the given index to the top of the stack.
    /// Does no bounds checking.
    #[inline(always)]
    unsafe fn push_local_unchecked(&mut self, idx: usize) {
        self.push_unchecked(
            self.contents
                .get_unchecked(self.bottom_func + idx as usize)
                .clone(),
        );
    }

    /// Pushes the global with the given index (AKA the local of the main function with the given index) to the top the stack.
    #[inline(always)]
    fn push_global(&mut self, idx: usize) {
        self.push(self.contents[idx as usize].clone());
    }

    /// Pops the value at the top of the stack and saves it to the given local.
    #[inline(always)]
    fn save_local(&mut self, idx: usize) {
        self.contents[self.bottom_func + idx] = self.pop();
    }

    /// Pops the value at the top of the stack and saves it to the given local.
    #[inline(always)]
    unsafe fn save_local_unchecked(&mut self, idx: usize) {
        *self.contents.get_unchecked_mut(self.bottom_func + idx) = self.pop_unchecked();
    }

    /// Pops the value at the top of the stack and saves it to the given global.
    #[inline(always)]
    fn save_global(&mut self, idx: usize) {
        self.contents[idx as usize] = self.pop();
    }

    /// Moves the top and bottom of the current stack frame so that the bottom of the frame
    /// starts at the beginning of the arguments pushed by the caller, and the top of the frame
    /// points to the first position that is not within the local variables of the function.
    #[inline(always)]
    fn move_to_function_call(
        &mut self,
        callee: &CheckedSubProgram,
    ) -> Result<StackState, RuntimeError> {
        // The top arg_count values on the stack serve as arguments to the sub-program, and the sub-program's arguments
        // are its first `arg_count` local variables.
        let at_start_of_locals = self.top - callee.inner.arg_count as usize;

        // Verify that the maxiumum offset the called sub-program could reach
        // from the bottom of its stack frame is still within the stack.
        if at_start_of_locals + callee.max_stack_size >= self.contents.len() {
            return Err(RuntimeError::StackOverflow); // Otherwise, the stack has overflowed.
        }

        // After execution, the arguments for this sub-program should no longer be on stack.
        let state = StackState {
            // Thus, the index of the first argument becomes the new top of the stack (which is the first index *not* in the stack)
            stack_frame_top: at_start_of_locals,
            stack_frame_bottom: self.bottom_func,
        };

        self.bottom_func = at_start_of_locals;
        // Pushes to the stack after calling should push above the locals
        self.top = self.bottom_func + callee.inner.local_count as usize;
        Ok(state)
    }

    /// Moves to the given caller of the current function, assuming that there is no return value.
    #[inline(always)]
    fn move_to_caller(&mut self, exec_state: StackState) {
        self.bottom_func = exec_state.stack_frame_bottom;
        self.top = exec_state.stack_frame_top;
    }

    /// Moves to the given caller of the current function, pushing the return value to the stack.
    #[inline(always)]
    fn return_to_caller(&mut self, exec_state: StackState) {
        let return_value = self.pop();

        self.move_to_caller(exec_state);

        self.push(return_value);
    }
}

/// Executes the main sub-program within the given module
pub fn execute_main(module: &Module) -> Result<(), RuntimeError> {
    execute_idx(module, module.main_idx, &[])?;

    Ok(())
}

/// Executes the sub program with the given name within the given module.
pub fn execute_by_name(
    module: &Module,
    name: &str,
    args: &[Value],
) -> Result<Option<Value>, RuntimeError> {
    for (idx, sub_program) in module.sub_programs.iter().enumerate() {
        if sub_program.inner.name.as_deref() != Some(name) {
            continue;
        }

        return execute_idx(module, idx, args);
    }

    Err(RuntimeError::NoSuchSubProgram(name.to_owned()))
}

/// Executes the sub program with the given index within the given module.
#[inline(always)]
fn execute_idx(
    module: &Module,
    sub_program_idx: usize,
    args: &[Value],
) -> Result<Option<Value>, RuntimeError> {
    // Create the stack which holds values being used by functions
    let mut stack = Stack::new(4096);
    // Create the call stack
    let mut call_stack = Vec::new();

    // Move the stack pointer to after the locals of the main procedure (to make global variables available to other sub-programs
    // and to make local variables available to main)
    let main_proc = &module.sub_programs[module.main_idx];
    stack.move_to_function_call(main_proc)?;

    // Prepare the stack for the sub-program we're starting execution at, if it isn't main
    let entry_sub_program = &module.sub_programs[sub_program_idx];
    if entry_sub_program != main_proc {
        if args.len() != entry_sub_program.inner.arg_count {
            return Err(RuntimeError::WrongNumberOfArguments {
                name: entry_sub_program
                    .inner
                    .name
                    .clone()
                    .expect("Non-main sub-program will always have a name"),
                expected: entry_sub_program.inner.arg_count,
                actual: args.len(),
            });
        }

        // Simulate a function call to the sub-program
        for arg in args {
            stack.push(arg.clone());
        }
        stack.move_to_function_call(entry_sub_program)?;
    }

    // Start execution at the beginning of the given sub-program
    let mut state = InstructionState::at_beginning_of(&entry_sub_program.inner);
    loop {
        let instruction = match state
            .sub_program
            .instructions
            .get(state.instruction_ptr as usize)
        {
            Some(instruction) => instruction,
            None => &Instruction::Return, // If we are out of instructions, we will execute `Return` to move back up the call stack.
        };

        match instruction {
            // Very repetitive code for binary operations.
            // This code could be moved elsewhere, but I decided against it, since the functions wouldn't be used much elsewhere.
            Instruction::Add => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left + right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left + right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 + right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left + right))
                },
                (Value::String(right), Value::String(left)) => unsafe {
                    stack.push_unchecked(Value::String(RcStr::concat(&*left, &*right)))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Add)),
            },
            Instruction::Subtract => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left - right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left - right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 - right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left - right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Subtract)),
            },
            Instruction::Multiply => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left * right))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left * right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 * right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left * right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Multiply)),
            },
            Instruction::Divide => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 / right as f64))
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left / right as f64))
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left as f64 / right))
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(Value::Real(left / right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Divide)),
            },
            Instruction::Remainder => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(Value::Integer(left % right))
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Remainder)),
            },
            Instruction::Quotient => match (stack.pop(), stack.pop()) {
                (Value::Integer(right), Value::Integer(left)) => {
                    stack.push(Value::Integer(left / right))
                }
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Quotient)),
            },
            Instruction::Power => match (stack.pop(), stack.pop()) {
                (Value::Integer(right), Value::Integer(left)) => {
                    stack.push(Value::Integer(left.pow(right as u32)))
                }
                (Value::Integer(right), Value::Real(left)) => {
                    stack.push(Value::Real(left.powf(right as f64)))
                }
                (Value::Real(right), Value::Integer(left)) => {
                    stack.push(Value::Real((left as f64).powf(right)))
                }
                (Value::Real(right), Value::Real(left)) => {
                    stack.push(Value::Real(left.powf(right)))
                }
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Power)),
            },
            Instruction::GreaterThan => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left > right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left > right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::GreaterThan,
                    ))
                }
            },
            Instruction::GreaterThanOrEquals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left >= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left >= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::GreaterThanOrEquals,
                    ))
                }
            },
            Instruction::LessThan => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left < right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left < right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if (left as f64) < right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left < right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::LessThan)),
            },
            Instruction::LessThanOrEquals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left <= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left <= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if (left as f64) <= right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left <= right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                _ => {
                    return Err(RuntimeError::CannotBinaryOperate(
                        BinaryOperator::LessThanOrEquals,
                    ))
                }
            },
            Instruction::Equals => match unsafe { stack.pop_twice_unchecked() } {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left == right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left == right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::True, Value::True) => stack.push(Value::True),
                (Value::True, Value::False) => stack.push(Value::False),
                (Value::False, Value::True) => stack.push(Value::False),
                (Value::False, Value::False) => stack.push(Value::True),
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::Equals)),
            },
            Instruction::NotEquals => match (stack.pop(), stack.pop()) {
                (Value::Integer(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Integer(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left != right as f64 {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Integer(left)) => unsafe {
                    stack.push_unchecked(if left as f64 != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::Real(right), Value::Real(left)) => unsafe {
                    stack.push_unchecked(if left != right {
                        Value::True
                    } else {
                        Value::False
                    })
                },
                (Value::True, Value::True) => stack.push(Value::False),
                (Value::True, Value::False) => stack.push(Value::True),
                (Value::False, Value::True) => stack.push(Value::True),
                (Value::False, Value::False) => stack.push(Value::False),
                _ => return Err(RuntimeError::CannotBinaryOperate(BinaryOperator::NotEquals)),
            },
            Instruction::Not => match unsafe { stack.pop_unchecked() } {
                Value::True => stack.push(Value::False),
                Value::False => stack.push(Value::True),
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfTrue(idx) => match unsafe { stack.pop_unchecked() } {
                Value::True => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                Value::False => {}
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfFalse(idx) => match unsafe { stack.pop_unchecked() } {
                Value::True => {}
                Value::False => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfFalsePopIfTrue(idx) => match unsafe { stack.peek_unchecked() } {
                Value::True => unsafe {
                    stack.pop_unchecked();
                },
                Value::False => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::JumpIfTruePopIfFalse(idx) => match unsafe { stack.peek_unchecked() } {
                Value::True => {
                    state.instruction_ptr = *idx;
                    continue;
                }
                Value::False => unsafe {
                    stack.pop_unchecked();
                },
                _ => {
                    return Err(RuntimeError::WrongType {
                        expected: Type::Boolean,
                    })
                }
            },
            Instruction::Jump(idx) => {
                state.instruction_ptr = *idx;
                continue;
            }
            Instruction::Call(func_idx) => {
                let to_call = &module.sub_programs[*func_idx as usize];
                let stack_state = stack.move_to_function_call(to_call)?;

                call_stack.push(ExecState {
                    instruction: state,
                    stack: stack_state,
                });
                state = InstructionState::at_beginning_of(&to_call.inner);
                continue;
            }
            Instruction::Return => {
                if state.sub_program.is_function {
                    return Err(RuntimeError::MustReturnValueFromFunction);
                }

                let caller_state = match call_stack.pop() {
                    Some(state) => state,
                    None => return Ok(None),
                };

                stack.move_to_caller(caller_state.stack);
                state = caller_state.instruction;
            }
            Instruction::ReturnValue => {
                if !state.sub_program.is_function {
                    return Err(RuntimeError::CannotReturnValueFromProcedure);
                }

                let caller_state = match call_stack.pop() {
                    Some(state) => state,
                    None => return Ok(Some(unsafe { stack.pop_unchecked() })),
                };

                stack.return_to_caller(caller_state.stack);
                state = caller_state.instruction;
            }
            Instruction::LoadInteger(int) => unsafe { stack.push_unchecked(Value::Integer(*int)) },
            Instruction::LoadReal(real) => unsafe { stack.push_unchecked(Value::Real(*real)) },
            Instruction::LoadTrue => unsafe { stack.push_unchecked(Value::True) },
            Instruction::LoadFalse => unsafe { stack.push_unchecked(Value::False) },
            Instruction::LoadString(string) => unsafe {
                stack.push_unchecked(Value::String(string.clone()))
            },
            Instruction::Load(local_idx) => unsafe { stack.push_local_unchecked(*local_idx) },
            Instruction::LoadGlobal(global_idx) => stack.push_global(*global_idx),
            Instruction::Save(local_idx) => unsafe { stack.save_local_unchecked(*local_idx) },
            Instruction::SaveGlobal(global_idx) => stack.save_global(*global_idx),
            Instruction::Pop => {
                unsafe { stack.pop_unchecked() };
            }
            Instruction::Throw(err) => return Err((**err).clone()),
            Instruction::Nop => {}
            Instruction::CallNative(call_info) => (call_info.ptr.0)(&mut stack)?,
        };

        // Advance to the next instruction
        state.instruction_ptr += 1;
    }
}
